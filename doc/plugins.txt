Plugin architecture for Advene
------------------------------

Types of plugins
================

  * content-type handler (editor / viewer)
  * adhoc views
  * actions
  * importers
  * global methods

Location of plugins
===================

For the builtin core features: lib/advene/plugins

For the builtin GUI features: lib/advene/gui/plugins

For user-defined plugins: $HOME/.advene/plugins ($HOME/advene/plugins on windows)

Implementation
==============

A plugin is a module. It *must* have :
  * a name attribute
  * a register(controller=None) function

The register function is called, with the controller as parameter,
upon loading. It has to initialize and register the plugin's
components in the Advene infrastructure.

For the moment, the following registration methods are available from
the controller:

register_content_handler(handler)
register_global_method(method, name=None)
register_action(action)
register_viewclass(class)
register_importer(importer)

Example
=======

Here is a minimal plugin to register a new global method (in TALES):

  name="Test plugin"
  
  def register(controller=None):
      controller.register_global_method(test_global_method, 'test')
        
  def test_global_method(target, context):
      return "TEST"

You can find a real example in lib/advene/gui/plugins/actions.py

Component-specific information
==============================

Adhoc-views have to inherit from advene.gui.views.AdhocView in order
to be integrated in the Advene framework.

Importers have to inherit from advene.util.importer.GenericImporter

Content-type handlers have to inherit from advene.gui.edit.elements.ContentHandler

Actions must be wrapped in a advene.rules.elements.RegisteredAction

Global methods must respect the signature: function(context, target)
